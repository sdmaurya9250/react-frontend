import { useEffect, useRef, useState } from "react";
import io from "socket.io-client";

const socket = io("http://localhost:5000");

export default function VideoChat() {
  const localVideoRef = useRef(null);
  const remoteVideoRef = useRef(null);
  const peerConnectionRef = useRef(null);
  const localStreamRef = useRef(null);

  const [connected, setConnected] = useState(false);
  const [searching, setSearching] = useState(false);
  const [micOn, setMicOn] = useState(true);
  const [cameraOn, setCameraOn] = useState(true);

  // TEXT CHAT
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState("");



  useEffect(() => {
  socket.on("connect", () => {
    console.log("✅ Socket connected:", socket.id);
  });

  socket.on("disconnect", () => {
    console.log("❌ Socket disconnected");
  });

  return () => {
    socket.off("connect");
    socket.off("disconnect");
  };
}, []);



  // ======================
  // CREATE PEER CONNECTION
  // ======================
const createPeerConnection = () => {
  const pc = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
  });

  pc.ontrack = (event) => {
    remoteVideoRef.current.srcObject = event.streams[0];
  };

  pc.onicecandidate = (event) => {
    if (event.candidate) {
      socket.emit("ice-candidate", event.candidate);
    }
  };

  return pc;
};


  // ======================
  // START CAMERA
  // ======================
const startCamera = async () => {
  if (localStreamRef.current) return;

  const stream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true,
  });

  localStreamRef.current = stream;
  localVideoRef.current.srcObject = stream;
};


  // ======================
  // FIND STRANGER
  // ======================
  const findStranger = async () => {
    setSearching(true);
    await startCamera();

    peerConnectionRef.current = createPeerConnection();

    localStreamRef.current.getTracks().forEach((track) => {
      peerConnectionRef.current.addTrack(track, localStreamRef.current);
    });

    socket.emit("find-stranger");
  };

  // ======================
  // NEXT USER
  // ======================
  const nextUser = () => {
    endCall();
    socket.emit("next-user");
    setSearching(true);
  };

  // ======================
  // MUTE MIC
  // ======================
  const toggleMic = () => {
    localStreamRef.current?.getAudioTracks().forEach((track) => {
      track.enabled = !track.enabled;
      setMicOn(track.enabled);
    });
  };

  // ======================
  // CAMERA ON / OFF
  // ======================
  const toggleCamera = () => {
    localStreamRef.current?.getVideoTracks().forEach((track) => {
      track.enabled = !track.enabled;
      setCameraOn(track.enabled);
    });
  };

  // ======================
  // SEND MESSAGE
  // ======================
  const sendMessage = () => {
    if (!message.trim()) return;

    socket.emit("chat-message", message);
    setMessages((prev) => [...prev, { from: "me", text: message }]);
    setMessage("");
  };

  // ======================
  // REPORT USER
  // ======================
  const reportUser = () => {
    socket.emit("report-user");
    alert("User reported. You will be disconnected.");
    nextUser();
  };

  // ======================
  // END CALL
  // ======================
  const endCall = () => {
    setConnected(false);
    setSearching(false);
    setMessages([]);
    setMicOn(true);
    setCameraOn(true);

    if (peerConnectionRef.current) {
      peerConnectionRef.current.close();
      peerConnectionRef.current = null;
    }

    if (localStreamRef.current) {
      localStreamRef.current.getTracks().forEach((t) => t.stop());
      localStreamRef.current = null;
    }

    if (remoteVideoRef.current) {
      remoteVideoRef.current.srcObject = null;
    }
  };

  // ======================
  // SOCKET EVENTS
  // ======================
  useEffect(() => {
    // socket.on("match-found", async () => {
    //   const offer = await peerConnectionRef.current.createOffer();
    //   await peerConnectionRef.current.setLocalDescription(offer);
    //   socket.emit("offer", offer);
    //   setConnected(true);
    //   setSearching(false);
    // });

socket.on("match-found", async ({ role }) => {
  await startCamera();

  peerConnectionRef.current = createPeerConnection();

  localStreamRef.current.getTracks().forEach(track => {
    peerConnectionRef.current.addTrack(track, localStreamRef.current);
  });

  if (role === "caller") {
    const offer = await peerConnectionRef.current.createOffer();
    await peerConnectionRef.current.setLocalDescription(offer);
    socket.emit("offer", offer);
  }

  setConnected(true);
  setSearching(false);
});



socket.on("offer", async (offer) => {
  await peerConnectionRef.current.setRemoteDescription(offer);

  const answer = await peerConnectionRef.current.createAnswer();
  await peerConnectionRef.current.setLocalDescription(answer);

  socket.emit("answer", answer);
});


socket.on("answer", async (answer) => {
  await peerConnectionRef.current.setRemoteDescription(answer);
});



    socket.on("ice-candidate", async (candidate) => {
      await peerConnectionRef.current.addIceCandidate(candidate);
    });

    socket.on("partner-disconnected", () => {
      endCall();
    });

    socket.on("chat-message", (msg) => {
      setMessages((prev) => [...prev, { from: "stranger", text: msg }]);
    });

    return () => socket.off();
  }, []);

  // ======================
  // UI
  // ======================
  return (
    <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center p-4">
      {/* VIDEOS */}
      <div className="flex gap-4">
      <video
  ref={localVideoRef}
  autoPlay
  muted
  playsInline
  className="w-64 h-48 bg-black rounded"
/>

<video
  ref={remoteVideoRef}
  autoPlay
  playsInline
  className="w-64 h-48 bg-black rounded"
/>


        {/* <video ref={localVideoRef} autoPlay muted className="w-64 h-48 bg-black rounded" />
        <video ref={remoteVideoRef} autoPlay className="w-64 h-48 bg-black rounded" /> */}
      </div>

      {/* CONTROLS */}
      <div className="mt-4 flex gap-2 flex-wrap justify-center">
{(connected || searching) && (
  <>
    <button onClick={toggleMic} className="px-4 py-2 bg-indigo-600 rounded">
      {micOn ? "Mute" : "Unmute"}
    </button>

    <button onClick={toggleCamera} className="px-4 py-2 bg-indigo-600 rounded">
      {cameraOn ? "Camera Off" : "Camera On"}
    </button>





            <button onClick={nextUser} className="px-4 py-2 bg-blue-600 rounded">
              Next
            </button>

            <button onClick={reportUser} className="px-4 py-2 bg-yellow-600 rounded">
              Report
            </button>

            <button onClick={endCall} className="px-4 py-2 bg-red-600 rounded">
              End
            </button>
          </>
        )}

        {!connected && !searching && (
          <button onClick={findStranger} className="px-6 py-2 bg-green-600 rounded">
            Start
          </button>
        )}

        {searching && <span className="px-4 py-2">Searching...</span>}
      </div>

      {/* CHAT */}
      {connected && (
        <div className="mt-4 w-full max-w-md bg-gray-800 p-3 rounded">
          <div className="h-40 overflow-y-auto mb-2">
            {messages.map((m, i) => (
              <div key={i} className={m.from === "me" ? "text-right" : "text-left"}>
                <span className="text-sm">{m.text}</span>
              </div>
            ))}
          </div>

          <div className="flex gap-2">
            <input
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              className="flex-1 px-2 py-1 text-black rounded"
              placeholder="Type message..."
            />
            <button onClick={sendMessage} className="px-4 bg-green-600 rounded">
              Send
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
